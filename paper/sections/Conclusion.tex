% !TeX root = ../thesis.tex
\section{Future Work}
There is much potential future work that could be done, some of which has been mentioned briefly already.
For example, the manual parameterized implementation of the life insurance plans seen in section \ref{sub:manual_parameterization} showed almost a doubling of performing with double precision floats compared to CUDA C and subsequently the parameterized CalcSpec-generated life insurance plans.
The main difference is the fact that parameters such as age and interest rate where passed down as method parameters and it was speculated that the difference in speed is due to this, but as of yet it is untested.

There are also minor improvements that could be made for CalcSpec such as variables being made usable in the \lstinline$range$ section of CalcSpec and respecting the values in \lstinline$output$ and \lstinline$boundaryvalues$.
The current type system used during conversion of CalcSpec to quotations is also too simplistic and does not natively support multi-parameter methods requiring hacks to support methods such as $\mu_{ai}$ and $\mu_{id}$ seen in section \ref{subsubsec:gf810parallelized}.
The limitations of the current type systems also makes implementing the parameter passing difficult.
There are also many limitations on how the \lstinline$delta$ method (see section \ref{subsec:delta}) can be used which are not all currently being checked, nor are the requirements communicated very well.

The expression reduction seen in section \ref{subsec:exprReduction} was also shown to have a small impact on performance but is still very simplistic, and more work could likely be done to even greater effect.

If not fixed by the authors of Alea.cuBase QuantAlea, more work should be done to allow for more states to allow plans such as the GF810 plan mentioned in section \ref{sub:gf810}.
When possible, performance implications of various types of memory should also be tested.

Variable shared memory also looks interesting. For low-register plans shared memory seems to be a detriment to the performance, but as an alternative to local memory it is much preferable.
Shared memory is however a limited resource and it is especially limited by the number of states in the life insurance model.
Intelligently selecting elements of the Runge-Kutta 4 solver to be moved to shared memory should provide a respectable increase in performance.

An interesting prospect would be moving the architecture to the cloud.
This would allow for parallelization utilizing multiple virtualized GPUs on an on-demand basis lessening the capital investment needed for intense parallel computing.
Whether the current cloud providers provide adequate virtualized GPU instances is the question and the performance impact is of great interest.

\section{Conclusion}
In this project a single-threaded C\# implementation of a Runge-Kutta 4 solver as well as six example life insurance plans (see section \ref{subsec:initialsolution}) has been transformed to utilize parallelization on the CUDA platform.
Furthermore, the Actulus Calculation Specification (CalcSpec, see section \ref{subsec:background:calcspec}) for life insurance products was made directly transformable into GPU code using F\# and Alea.cuBase (see section \ref{subsec:background:fsharpcubase} and \ref{sec:calcspecgeneration}).
Finally, the collective spouse pension (GF810, see section \ref{sub:gf810}) was improved by using a new calculation method by Klaus Grue which resulted in a performance increase of factor 150.

The performance for single precision floats was up to 2485 faster for the parameterized CalcSpec generated life insurance plans.
For double precision floats an improvement of factor 1335 was measured in the manual parameterized implementation while the CalcSpec generated implementation managed an improvement of factor 634.

Alea.cuBase, F\# and .NET as platforms have had little or no negative performance impact (seemingly quite the contrary) and has allowed for significantly more flexible GPU kernels by utilizing runtime-compilation of kernels.
This means that it is more than viable and a good alternative to CUDA C for life insurance policy parallelization.
The kernels are highly optimized but did show improvements from being optimized locally using expression reduction.
There are however some as of yet unsolved problems with Alea.cuBase as the provided methods for limiting registers in kernels did not work, and working with larger state models such as the GF810 collective spouse pension threw a stack overflow exception during kernel compilation for unknown reasons.

\clearpage