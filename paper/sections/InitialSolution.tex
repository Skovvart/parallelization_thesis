% !TeX root = ../thesis.tex
%The required reserve will increase with age, and likelihood of death, until retirement is reached in which no reserve will be needed.
\subsection{Initial C\# Solution}
The original solution was single-threaded and written in C\# by Peter Sestoft using various optimizations (such as for example using the exponential function rather than the power operator/function).
It features the 6 life insurance plans described in section \ref{subsubsec:background:insuranceplans} and multiple implementation of Runge-Kutta solvers.
The plans are implemented using C\# classes without inheritance or the like, as they attempt to stay relatively similar to a potential C-solution.

The Runge-Kutta 4 solver introduced last is the fastest and is an imperative version which reuses intermediary arrays.
It has the following signature: \textit{static double[][] RK4\_n(Action\textless{}double, double[], double[]\textgreater{} dV, Action\textless{}double, double[]\textgreater{} bj\_ii, int a, int b, int steps, double[] Va)}.
The $dV$ function implements an arbitrary amount of derivatives.
The $bj\_ii$ function is used for lump-sum payments.
$a$ and $b$ mark the calculation start and end points respectively, $steps$ are the amount of steps to use in Runge-Kutta 4 and \textit{Va} is the initial reserve (at time $a$).

An example implementation of the Pure Endowment life insurance plan can be seen below in code sample \ref{csharp_pureendowment}. 
Note that it does refer to some shared constants and methods defined outside the class itself, for example the $GM$ (Gompertz-Makeham) mortality-probability function which is referenced in all of the examples.
\clearpage
\begin{lstlisting}[language=CSharp, caption=The pure endowment insurance plan expressed in C\#, label=csharp_pureendowment]
class PureEndowment{
    static double b_0(double t){ return 0.0;}
    static double mu_01(double t){ return GM(t); }
    static double bj_00(double t){ return t == pensiontime ? bpension : 0.0; }
    static double bj_01(double t){ return 0.0; }
    public static double[][] Compute(){
        return RK4_n(
            (double t, double[] V, double[] res) => { 
                res[0] = r(t) * V[0] - b_0(t) - mu_01(t) * (0 - V[0] + bj_01(t)); 
            }, // dV
            (double t, double[] res) => { res[0] = bj_00(t); }, //bj_ii
            40, 0, steps, new double[] { 0 });
    }
}
\end{lstlisting}

Using floating point numbers with single precision (32-bit) it could do one iteration of all six plans in approximately \emph{25.3} milliseconds (ms), and with double precision (64-bit) it took approximately \emph{24.5} ms on the test machine.
It may come as a surprise that the single-precision-version was actually slower than the double-version despite using twice the amount of bits.
This is in part due to the fact that the exponential function $Exp$ from System.Math uses double-precision floats for both input and output (which requires type-casting in the single-precision version), but is mainly because double operations are optimized by the hardware\cite{northrup2008mcts}.
The single version should have an edge if the application was to become memory-bound but this was not the case with these example plans.